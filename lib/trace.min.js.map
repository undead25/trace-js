{"version":3,"file":"trace.min.js","sources":["../src/request.ts","../src/util.ts","../src/tracekit.js","../src/config.ts","../src/environment.ts","../src/breadcrumbs.ts","../src/onError.ts","../src/index.ts"],"sourcesContent":["export function makeRequest(options: any):void {\n  let request:XMLHttpRequest = new XMLHttpRequest();\n  const hasCORS:boolean = 'withCredentials' in request || typeof XDomainRequest !== 'undefined';\n\n  if (!hasCORS) return;\n\n  let url = options.url;\n  if ('withCredentials' in request) {\n    request.onreadystatechange = () => {\n      if (request.readyState !== 4) {\n        return;\n      } else if (request.status === 200) {\n        options.onSuccess = options.onSuccess();\n      } else if (options.onError) {\n        let error: any = new Error(`Error: ${request.status}`);\n        error.request = request;\n        options.onError(error);\n      }\n    }\n  } else {\n    // xdomainrequest cannot go http -> https (or vice versa),\n    // so always use protocol relative\n    request = new XDomainRequest();\n    url = url.replace(/^https?:/, '');\n\n    // onreadystatechange not supported by XDomainRequest\n    if(options.onSuccess) request.onload = options.onSuccess;\n    if(options.onError) {\n      request.onerror = () => {\n        let error: any = new Error(`Error: XDomainRequest`);\n        error.request = request;\n        options.onError(error);\n      }\n    }\n  }\n\n  request.open('POST', url, true);\n  request.send(JSON.stringify(options.data));\n}\n","\n/**\n * 是否为IE浏览器\n * @export\n * @returns {boolean} \n */\nexport function isIE(): boolean {\n  return navigator.appVersion.indexOf(\"MSIE\") !== -1;\n}\n\nexport function isError(value: any): boolean {\n  switch (Object.prototype.toString.call(value)) {\n    case '[object Error]': return true;\n    case '[object Exception]': return true;\n    case '[object DOMException]': return true;\n    default: return value instanceof Error;\n  }\n}\n\n/**\n * 生产唯一ID\n * @export\n * @returns {string} - 唯一guid\n */\nexport function guid(): string {\n  var crypto = window.crypto || window['msCrypto'];\n\n  if (crypto && crypto.getRandomValues) {\n    // Use window.crypto API if available\n    var arr = new Uint16Array(8);\n    crypto.getRandomValues(arr);\n\n    // set 4 in byte 7\n    arr[3] = arr[3] & 0xFFF | 0x4000;\n    // set 2 most significant bits of byte 9 to '10'\n    arr[4] = arr[4] & 0x3FFF | 0x8000;\n\n    var pad = function (num) {\n      var v = num.toString(16);\n      while (v.length < 4) {\n        v = '0' + v;\n      }\n      return v;\n    };\n\n    return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) +\n      pad(arr[5]) + pad(arr[6]) + pad(arr[7]);\n  } else {\n    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n      return v.toString(16);\n    });\n  }\n}\n\n/**\n * 文档绑定自定义事件\n * @export\n * @param {string} eventType \n * @param {Object} [options={}] \n * @returns {void} \n */\nexport function triggerEvent(eventType: string, options: Object = {}): void {\n  if (!document) return;\n\n  let _event: Event;\n  let key: string;\n\n  eventType = eventType.substr(0, 1).toUpperCase + eventType.substr(1);\n\n  if (document.createEvent) {\n    _event = document.createEvent('HTMLEvents');\n    _event.initEvent(eventType, true, true);\n  } else {\n    // IE8-9\n    _event = document['createEventObject']();\n    (_event as any).eventType = eventType;\n  }\n\n  for (key in options) {\n    if (options.hasOwnProperty(key)) {\n      _event[key] = options[key];\n    }\n  }\n\n  if (document.createEvent) {\n    document.dispatchEvent(_event);\n  } else {\n    document['fireEvent']('on' + (_event as any).eventType.toLowerCase(), _event);\n  }\n}\n\n/**\n * 原生方法垫片\n * @param {Object} obj - 内置对象，例：`window`, `document`\n * @param {string} name - 内置对象的函数名称，例：`addEventListener`\n * @param {Function} replacement - 替换后的函数\n * @param {*} [track] - record instrumentation to an array\n */\nexport function polyfill(obj: Object, name: string, replacement: Function, track?: any): void {\n  const origin = obj[name];\n  obj[name] = replacement(origin);\n  if (track) {\n    track.push([obj, name, origin]);\n  }\n}\n\nexport function wrap(options: any, func?: any, origin?: any) {\n  if (!func && typeof options !== 'function') return options;\n\n  if (typeof options === 'function') {\n    func = options;\n    options = undefined;\n  }\n\n  if (typeof func !== 'function') return func;\n\n  try {\n    if (func.trace) return func;\n    if (func.track_wrapper) return func.track_wrapper;\n  } catch (e) {\n    return func;\n  }\n\n  function wrapped() {\n    let trace, inner;\n    var args = [], i = arguments.length,\n      deep = !options || options && options.deep !== false;\n\n    if (origin && typeof origin === 'function') {\n      origin.apply(this, arguments);\n    }\n\n    while (i--) args[i] = deep ? wrap(options, arguments[i]) : arguments[i];\n\n    try {\n      return func.apply(this, args);\n    } catch (e) {\n      // self._ignoreNextOnError();\n      // self.captureException(e, options);\n      throw e;\n    }\n\n  }\n  // copy over properties of the old function\n  for (var property in func) {\n    if (func.hasOwnProperty(process)) {\n      wrapped[property] = func[property];\n    }\n  }\n  wrapped.prototype = func.prototype;\n\n  func.track_wrapper = wrapped;\n  // Signal that this function has been wrapped already\n  // for both debugging and to prevent it to being wrapped twice\n  // wrapped.trace = true;\n  // wrapped.inner = func;\n\n  return wrapped;\n}\n\n\n/**\n * \n * @param {Array<RegExp>} patterns \n * @returns {RegExp} \n */\nexport function joinRegExp(patterns: Array<RegExp>): RegExp {\n  let sources = [];\n  let pattern;\n  for (let i = 0; i < patterns.length; i++) {\n    pattern = patterns[i];\n    if (typeof pattern === 'string') {\n      sources.push(pattern.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1'));\n    } else if (pattern && pattern.source) {\n      // If it's a regexp already, we want to extract the source\n      sources.push(pattern.source);\n    }\n  }\n  return new RegExp(sources.join('|'), 'i');\n}\n\n/**\n * Given a child DOM element, returns a query-selector statement describing that\n * and its ancestors\n * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\n * @param elem\n * @returns {string}\n */\nexport function htmlTreeAsString(element: HTMLElement): string {\n  var MAX_TRAVERSE_HEIGHT = 5,\n    MAX_OUTPUT_LEN = 80,\n    out = [],\n    height = 0,\n    len = 0,\n    separator = ' > ',\n    sepLength = separator.length,\n    nextStr;\n\n  while (element && height++ < MAX_TRAVERSE_HEIGHT) {\n    nextStr = htmlElementAsString(element);\n    if (nextStr === 'html' || height > 1 && len + (out.length * sepLength) + nextStr.length >= MAX_OUTPUT_LEN) {\n      break;\n    }\n\n    out.push(nextStr);\n\n    len += nextStr.length;\n    element = element.parentElement;\n  }\n\n  return out.reverse().join(separator);\n}\n\n/**\n * Returns a simple, query-selector representation of a DOM element\n * e.g. [HTMLElement] => input#foo.btn[name=baz]\n * @param HTMLElement\n * @returns {string}\n */\nfunction htmlElementAsString(element: HTMLElement): string {\n  var out = [],\n    className,\n    classes,\n    key,\n    attr,\n    i;\n\n  if (!element || !element.tagName) {\n    return '';\n  }\n\n  out.push(element.tagName.toLowerCase());\n  if (element.id) {\n    out.push('#' + element.id);\n  }\n\n  className = element.className;\n  if (className && typeof className === 'string') {\n    classes = className.split(/\\s+/);\n    for (i = 0; i < classes.length; i++) {\n      out.push('.' + classes[i]);\n    }\n  }\n  var attrWhitelist = ['type', 'name', 'title', 'alt'];\n  for (i = 0; i < attrWhitelist.length; i++) {\n    key = attrWhitelist[i];\n    attr = element.getAttribute(key);\n    if (attr) {\n      out.push('[' + key + '=\"' + attr + '\"]');\n    }\n  }\n  return out.join('');\n}\n\n// borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n// intentionally using regex and not <a/> href parsing trick because React Native and other\n// environments where DOM might not be available\nexport function parseUrl(url: string) {\n  var match = url.match(/^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n  if (!match) return;\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  var query = match[6] || '';\n  var fragment = match[8] || '';\n  return {\n    protocol: match[2],\n    host: match[4],\n    path: match[5],\n    relative: match[5] + query + fragment // everything minus origin\n  };\n}\n\n/**\n * 获取元素的属性值 \n * @param {HTMLElement} element  - 需要获取属性的元素\n * @returns {Object} - 属性键值对象\n */\nexport function getAttributes(element: HTMLElement): Object {\n  const result: Object = {};\n  const attributes: NamedNodeMap = element.attributes;\n\n  for (let i = 0; i < attributes.length; i++) {\n    const item = attributes[i];\n    result[item.name] = item.value;\n  }\n\n  return result;\n}","'use strict';\n\n/*\n TraceKit - Cross brower stack traces\n\n This was originally forked from github.com/occ/TraceKit, but has since been\n largely re-written and is now maintained as part of raven-js.  Tests for\n this are in test/vendor.\n\n MIT license\n*/\n\nvar TraceKit = {\n    collectWindowErrors: true,\n    debug: false\n};\n\n// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)\nvar _window = typeof window !== 'undefined' ? window\n            : typeof global !== 'undefined' ? global\n            : typeof self !== 'undefined' ? self\n            : {};\n\n// global reference to slice\nvar _slice = [].slice;\nvar UNKNOWN_FUNCTION = '?';\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nvar ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;\n\nfunction getLocationHref() {\n    if (typeof document === 'undefined' || typeof document.location === 'undefined')\n        return '';\n\n    return document.location.href;\n}\n\n\n/**\n * TraceKit.report: cross-browser processing of unhandled exceptions\n *\n * Syntax:\n *   TraceKit.report.subscribe(function(stackInfo) { ... })\n *   TraceKit.report.unsubscribe(function(stackInfo) { ... })\n *   TraceKit.report(exception)\n *   try { ...code... } catch(ex) { TraceKit.report(ex); }\n *\n * Supports:\n *   - Firefox: full stack trace with line numbers, plus column number\n *              on top frame; column number is not guaranteed\n *   - Opera:   full stack trace with line and column numbers\n *   - Chrome:  full stack trace with line and column numbers\n *   - Safari:  line and column number for the top frame only; some frames\n *              may be missing, and column number is not guaranteed\n *   - IE:      line and column number for the top frame only; some frames\n *              may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n *   - IE5.5+ (only 8.0 tested)\n *   - Firefox 0.9+ (only 3.5+ tested)\n *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n *     Exceptions Have Stacktrace to be enabled in opera:config)\n *   - Safari 3+ (only 4+ tested)\n *   - Chrome 1+ (only 5+ tested)\n *   - Konqueror 3.5+ (untested)\n *\n * Requires TraceKit.computeStackTrace.\n *\n * Tries to catch all unhandled exceptions and report them to the\n * subscribed handlers. Please note that TraceKit.report will rethrow the\n * exception. This is REQUIRED in order to get a useful stack trace in IE.\n * If the exception does not reach the top of the browser, you will only\n * get a stack trace from the point where TraceKit.report was called.\n *\n * Handlers receive a stackInfo object as described in the\n * TraceKit.computeStackTrace docs.\n */\nTraceKit.report = (function reportModuleWrapper() {\n    var handlers = [],\n        lastArgs = null,\n        lastException = null,\n        lastExceptionStack = null;\n\n    /**\n     * Add a crash handler.\n     * @param {Function} handler\n     */\n    function subscribe(handler) {\n        installGlobalHandler();\n        handlers.push(handler);\n    }\n\n    /**\n     * Remove a crash handler.\n     * @param {Function} handler\n     */\n    function unsubscribe(handler) {\n        for (var i = handlers.length - 1; i >= 0; --i) {\n            if (handlers[i] === handler) {\n                handlers.splice(i, 1);\n            }\n        }\n    }\n\n    /**\n     * Remove all crash handlers.\n     */\n    function unsubscribeAll() {\n        uninstallGlobalHandler();\n        handlers = [];\n    }\n\n    /**\n     * Dispatch stack information to all handlers.\n     * @param {Object.<string, *>} stack\n     */\n    function notifyHandlers(stack, isWindowError) {\n        var exception = null;\n        if (isWindowError && !TraceKit.collectWindowErrors) {\n          return;\n        }\n        for (var i in handlers) {\n            if (handlers.hasOwnProperty(i)) {\n                try {\n                    handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));\n                } catch (inner) {\n                    exception = inner;\n                }\n            }\n        }\n\n        if (exception) {\n            throw exception;\n        }\n    }\n\n    var _oldOnerrorHandler, _onErrorHandlerInstalled;\n\n    /**\n     * Ensures all global unhandled exceptions are recorded.\n     * Supported by Gecko and IE.\n     * @param {string} message Error message.\n     * @param {string} url URL of script that generated the exception.\n     * @param {(number|string)} lineNo The line number at which the error\n     * occurred.\n     * @param {?(number|string)} colNo The column number at which the error\n     * occurred.\n     * @param {?Error} ex The actual Error object.\n     */\n    function traceKitWindowOnError(message, url, lineNo, colNo, ex) {\n        var stack = null;\n\n        if (lastExceptionStack) {\n            TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);\n            processLastException();\n        } else if (ex) {\n            // non-string `ex` arg; attempt to extract stack trace\n\n            // New chrome and blink send along a real error object\n            // Let's just report that like a normal error.\n            // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror\n            stack = TraceKit.computeStackTrace(ex);\n            notifyHandlers(stack, true);\n        } else {\n            var location = {\n                'url': url,\n                'line': lineNo,\n                'column': colNo\n            };\n\n            var name = undefined;\n            var msg = message; // must be new var or will modify original `arguments`\n            var groups;\n            if ({}.toString.call(message) === '[object String]') {\n                var groups = message.match(ERROR_TYPES_RE);\n                if (groups) {\n                    name = groups[1];\n                    msg = groups[2];\n                }\n            }\n\n            location.func = UNKNOWN_FUNCTION;\n\n            stack = {\n                'name': name,\n                'message': msg,\n                'url': getLocationHref(),\n                'stack': [location]\n            };\n            notifyHandlers(stack, true);\n        }\n\n        if (_oldOnerrorHandler) {\n            return _oldOnerrorHandler.apply(this, arguments);\n        }\n\n        return false;\n    }\n\n    function installGlobalHandler ()\n    {\n        if (_onErrorHandlerInstalled) {\n            return;\n        }\n        _oldOnerrorHandler = _window.onerror;\n        _window.onerror = traceKitWindowOnError;\n        _onErrorHandlerInstalled = true;\n    }\n\n    function uninstallGlobalHandler ()\n    {\n        if (!_onErrorHandlerInstalled) {\n            return;\n        }\n        _window.onerror = _oldOnerrorHandler;\n        _onErrorHandlerInstalled = false;\n        _oldOnerrorHandler = undefined;\n    }\n\n    function processLastException() {\n        var _lastExceptionStack = lastExceptionStack,\n            _lastArgs = lastArgs;\n        lastArgs = null;\n        lastExceptionStack = null;\n        lastException = null;\n        notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));\n    }\n\n    /**\n     * Reports an unhandled Error to TraceKit.\n     * @param {Error} ex\n     * @param {?boolean} rethrow If false, do not re-throw the exception.\n     * Only used for window.onerror to not cause an infinite loop of\n     * rethrowing.\n     */\n    function report(ex, rethrow) {\n        var args = _slice.call(arguments, 1);\n        if (lastExceptionStack) {\n            if (lastException === ex) {\n                return; // already caught by an inner catch block, ignore\n            } else {\n              processLastException();\n            }\n        }\n\n        var stack = TraceKit.computeStackTrace(ex);\n        lastExceptionStack = stack;\n        lastException = ex;\n        lastArgs = args;\n\n        // If the stack trace is incomplete, wait for 2 seconds for\n        // slow slow IE to see if onerror occurs or not before reporting\n        // this exception; otherwise, we will end up with an incomplete\n        // stack trace\n        setTimeout(function () {\n            if (lastException === ex) {\n                processLastException();\n            }\n        }, (stack.incomplete ? 2000 : 0));\n\n        if (rethrow !== false) {\n            throw ex; // re-throw to propagate to the top level (and cause window.onerror)\n        }\n    }\n\n    report.subscribe = subscribe;\n    report.unsubscribe = unsubscribe;\n    report.uninstall = unsubscribeAll;\n    return report;\n}());\n\n/**\n * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)\n * Returns:\n *   s.name              - exception name\n *   s.message           - exception message\n *   s.stack[i].url      - JavaScript or HTML file URL\n *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)\n *   s.stack[i].args     - arguments passed to the function, if known\n *   s.stack[i].line     - line number, if known\n *   s.stack[i].column   - column number, if known\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * TraceKit.computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with TraceKit.report,\n * which builds on top of TraceKit.computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n */\nTraceKit.computeStackTrace = (function computeStackTraceWrapper() {\n    // Contents of Exception in various browsers.\n    //\n    // SAFARI:\n    // ex.message = Can't find variable: qq\n    // ex.line = 59\n    // ex.sourceId = 580238192\n    // ex.sourceURL = http://...\n    // ex.expressionBeginOffset = 96\n    // ex.expressionCaretOffset = 98\n    // ex.expressionEndOffset = 98\n    // ex.name = ReferenceError\n    //\n    // FIREFOX:\n    // ex.message = qq is not defined\n    // ex.fileName = http://...\n    // ex.lineNumber = 59\n    // ex.columnNumber = 69\n    // ex.stack = ...stack trace... (see the example below)\n    // ex.name = ReferenceError\n    //\n    // CHROME:\n    // ex.message = qq is not defined\n    // ex.name = ReferenceError\n    // ex.type = not_defined\n    // ex.arguments = ['aa']\n    // ex.stack = ...stack trace...\n    //\n    // INTERNET EXPLORER:\n    // ex.message = ...\n    // ex.name = ReferenceError\n    //\n    // OPERA:\n    // ex.message = ...message... (see the example below)\n    // ex.name = ReferenceError\n    // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n    // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\n    /**\n     * Computes stack trace information from the stack property.\n     * Chrome and Gecko use this property.\n     * @param {Error} ex\n     * @return {?Object.<string, *>} Stack trace information.\n     */\n    function computeStackTraceFromStackProp(ex) {\n        if (typeof ex.stack === 'undefined' || !ex.stack) return;\n\n        var chrome = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i,\n            gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?)(?::(\\d+))?(?::(\\d+))?\\s*$/i,\n            winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i,\n\n            // Used to additionally parse URL/line/column from eval frames\n            geckoEval = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i,\n            chromeEval = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/,\n\n            lines = ex.stack.split('\\n'),\n            stack = [],\n            submatch,\n            parts,\n            element,\n            reference = /^(.*) is undefined$/.exec(ex.message);\n\n        for (var i = 0, j = lines.length; i < j; ++i) {\n            if ((parts = chrome.exec(lines[i]))) {\n                var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n                var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n                if (isEval && (submatch = chromeEval.exec(parts[2]))) {\n                    // throw out eval line/column and use top-most line/column number\n                    parts[2] = submatch[1]; // url\n                    parts[3] = submatch[2]; // line\n                    parts[4] = submatch[3]; // column\n                }\n                element = {\n                    'url': !isNative ? parts[2] : null,\n                    'func': parts[1] || UNKNOWN_FUNCTION,\n                    'args': isNative ? [parts[2]] : [],\n                    'line': parts[3] ? +parts[3] : null,\n                    'column': parts[4] ? +parts[4] : null\n                };\n            } else if ( parts = winjs.exec(lines[i]) ) {\n                element = {\n                    'url': parts[2],\n                    'func': parts[1] || UNKNOWN_FUNCTION,\n                    'args': [],\n                    'line': +parts[3],\n                    'column': parts[4] ? +parts[4] : null\n                };\n            } else if ((parts = gecko.exec(lines[i]))) {\n                var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n                if (isEval && (submatch = geckoEval.exec(parts[3]))) {\n                    // throw out eval line/column and use top-most line number\n                    parts[3] = submatch[1];\n                    parts[4] = submatch[2];\n                    parts[5] = null; // no column when eval\n                } else if (i === 0 && !parts[5] && typeof ex.columnNumber !== 'undefined') {\n                    // FireFox uses this awesome columnNumber property for its top frame\n                    // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n                    // so adding 1\n                    // NOTE: this hack doesn't work if top-most frame is eval\n                    stack[0].column = ex.columnNumber + 1;\n                }\n                element = {\n                    'url': parts[3],\n                    'func': parts[1] || UNKNOWN_FUNCTION,\n                    'args': parts[2] ? parts[2].split(',') : [],\n                    'line': parts[4] ? +parts[4] : null,\n                    'column': parts[5] ? +parts[5] : null\n                };\n            } else {\n                continue;\n            }\n\n            if (!element.func && element.line) {\n                element.func = UNKNOWN_FUNCTION;\n            }\n\n            stack.push(element);\n        }\n\n        if (!stack.length) {\n            return null;\n        }\n\n        return {\n            'name': ex.name,\n            'message': ex.message,\n            'url': getLocationHref(),\n            'stack': stack\n        };\n    }\n\n    /**\n     * Adds information about the first frame to incomplete stack traces.\n     * Safari and IE require this to get complete data on the first frame.\n     * @param {Object.<string, *>} stackInfo Stack trace information from\n     * one of the compute* methods.\n     * @param {string} url The URL of the script that caused an error.\n     * @param {(number|string)} lineNo The line number of the script that\n     * caused an error.\n     * @param {string=} message The error generated by the browser, which\n     * hopefully contains the name of the object that caused the error.\n     * @return {boolean} Whether or not the stack information was\n     * augmented.\n     */\n    function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {\n        var initial = {\n            'url': url,\n            'line': lineNo\n        };\n\n        if (initial.url && initial.line) {\n            stackInfo.incomplete = false;\n\n            if (!initial.func) {\n                initial.func = UNKNOWN_FUNCTION;\n            }\n\n            if (stackInfo.stack.length > 0) {\n                if (stackInfo.stack[0].url === initial.url) {\n                    if (stackInfo.stack[0].line === initial.line) {\n                        return false; // already in stack trace\n                    } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {\n                        stackInfo.stack[0].line = initial.line;\n                        return false;\n                    }\n                }\n            }\n\n            stackInfo.stack.unshift(initial);\n            stackInfo.partial = true;\n            return true;\n        } else {\n            stackInfo.incomplete = true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Computes stack trace information by walking the arguments.caller\n     * chain at the time the exception occurred. This will cause earlier\n     * frames to be missed but is the only way to get any stack trace in\n     * Safari and IE. The top frame is restored by\n     * {@link augmentStackTraceWithInitialElement}.\n     * @param {Error} ex\n     * @return {?Object.<string, *>} Stack trace information.\n     */\n    function computeStackTraceByWalkingCallerChain(ex, depth) {\n        var functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i,\n            stack = [],\n            funcs = {},\n            recursion = false,\n            parts,\n            item,\n            source;\n\n        for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {\n            if (curr === computeStackTrace || curr === TraceKit.report) {\n                // console.log('skipping internal function');\n                continue;\n            }\n\n            item = {\n                'url': null,\n                'func': UNKNOWN_FUNCTION,\n                'line': null,\n                'column': null\n            };\n\n            if (curr.name) {\n                item.func = curr.name;\n            } else if ((parts = functionName.exec(curr.toString()))) {\n                item.func = parts[1];\n            }\n\n            if (typeof item.func === 'undefined') {\n              try {\n                item.func = parts.input.substring(0, parts.input.indexOf('{'));\n              } catch (e) { }\n            }\n\n            if (funcs['' + curr]) {\n                recursion = true;\n            }else{\n                funcs['' + curr] = true;\n            }\n\n            stack.push(item);\n        }\n\n        if (depth) {\n            // console.log('depth is ' + depth);\n            // console.log('stack is ' + stack.length);\n            stack.splice(0, depth);\n        }\n\n        var result = {\n            'name': ex.name,\n            'message': ex.message,\n            'url': getLocationHref(),\n            'stack': stack\n        };\n        augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);\n        return result;\n    }\n\n    /**\n     * Computes a stack trace for an exception.\n     * @param {Error} ex\n     * @param {(string|number)=} depth\n     */\n    function computeStackTrace(ex, depth) {\n        var stack = null;\n        depth = (depth == null ? 0 : +depth);\n\n        try {\n            stack = computeStackTraceFromStackProp(ex);\n            if (stack) {\n                return stack;\n            }\n        } catch (e) {\n            if (TraceKit.debug) {\n                throw e;\n            }\n        }\n\n        try {\n            stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);\n            if (stack) {\n                return stack;\n            }\n        } catch (e) {\n            if (TraceKit.debug) {\n                throw e;\n            }\n        }\n        return {\n            'name': ex.name,\n            'message': ex.message,\n            'url': getLocationHref()\n        };\n    }\n\n    computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;\n    computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;\n\n    return computeStackTrace;\n}());\n\nexport default TraceKit;\n","\nexport const defaultConfig: Trace.Config = {\n  apiKey: '',\n  enabled: true,\n  reportUrl: 'http://localhost:3001/tracer/error',\n  ignoreErrors: [],\n  ignoreUrls: [],\n  autoBreadcrumbs: {\n    dom: true,\n    xhr: true,\n    location: true,\n    console: false\n  },\n  releaseStage: 'production',\n  catchAjax: true,\n  catchConsole: true,\n  disableLog: false,\n  maxStackDepth: 10,\n  repeatReport: false,\n  maxBreadcrumbs: 100\n}\n","\nexport const environment: Trace.Environment = {\n  /** 屏幕宽度 */\n  screenWidth: (document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth),\n  /** 屏幕高度 */\n  screenHeigth: (document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight),\n  /** 浏览器信息 */\n  userAgent: navigator.userAgent,\n  /** 浏览器语言 */\n  language: navigator.language\n}\n","import { getAttributes, htmlTreeAsString, polyfill, wrap, parseUrl } from './util';\nimport { OnError } from './onError';\nconst objectAssign = Object.assign || require('object-assign');\n\nexport class BreadCrumbs {\n  public crumbsData: Array<Trace.BreadCrumb> = [];\n\n  private _config: Trace.Config;\n  private wrappedBuiltIns: Array<any> = [];\n\n  private clickEventSelectors: Array<string>;\n  private changeEventSelectors: Array<string>;\n\n  private lastEvent: Event = null;\n  private lastHref: string = '';\n\n  constructor(config: Trace.Config) {\n    this._config = config;\n    this.getDomBreadcrumbs();\n    this.getXhrBreadcrumbs();\n    this.getLocationBreadcurmbs();\n    this.getConsoleBreadcrumbs();\n  }\n\n  /**\n   * 获取事件操作并写入面包屑\n   * @private\n   */\n  private getDomBreadcrumbs(): void {\n    if (!this._config.autoBreadcrumbs.dom) return;\n\n    this.clickEventSelectors = ['a', 'button', 'input[button]', 'input[submit]', 'input[radio]', 'input[checkbox]'];\n    this.changeEventSelectors = ['input[text]', 'input[password]', 'textarea', 'select'];\n\n    if (document.addEventListener) {\n      document.addEventListener('click', (event: MouseEvent) => {\n        this.eventHandler('click', this.clickEventSelectors, event);\n      }, true);\n      document.addEventListener('blur', (event: MouseEvent) => {\n        this.eventHandler('input', this.changeEventSelectors, event)\n      }, true);\n    } else {\n      // IE8\n      document['attachEvent']('onclick', (event: MouseEvent) => {\n        this.eventHandler('click', this.clickEventSelectors, event);\n      });\n      document['attachEvent']('onblur', (event: MouseEvent) => {\n        this.eventHandler('click', this.clickEventSelectors, event);\n      })\n    }\n  }\n\n  /**\n   * \n   * @private\n   * @param {string} eventName \n   * @param {Array<string>} selectorFilters \n   * @param {MouseEvent} event \n   */\n  private eventHandler(eventName: string, selectorFilters: Array<string>, event: MouseEvent): void {\n    const target = event.target || event.srcElement;\n    const tagName: string = (target as HTMLElement).tagName.toLowerCase();\n\n    if (this.acceptTag(target as HTMLElement, selectorFilters)) {\n      const attributes = getAttributes(target as HTMLElement);\n      let inputElement = target as HTMLInputElement;\n\n      const result: Trace.BreadCrumb = {\n        category: `ui.${eventName}`,\n        htmlTree: htmlTreeAsString(target as HTMLElement)\n      }\n\n      this.captureBreadcrumb(result);\n    }\n  }\n\n  /**\n   * 查看某个元素是否在要监控的元素类型列表中\n   * @private\n   * @param {HTMLElement} element - 要检测的元素\n   * @param {Array<string>} selectors - 元素列表字符串\n   * @returns {boolean} - 检测结果\n   */\n  private acceptTag(element: HTMLElement, selectors: Array<string>): boolean {\n    let tag: string = element.tagName.toLowerCase();\n    if (tag === 'input' && element.getAttribute('type')) {\n      tag += `[${element.getAttribute('type')}]`\n    }\n    return selectors.indexOf(tag) > -1;\n  }\n\n\n  /**\n   * 获取事件操作并写入面包屑\n   */\n  private getXhrBreadcrumbs() {\n    if (!this._config.autoBreadcrumbs.xhr) return;\n\n    const self = this;\n    const autoBreadcrumbs = this._config.autoBreadcrumbs;\n    const wrappedBuiltIns = this.wrappedBuiltIns;\n    const xhrproto = XMLHttpRequest.prototype;\n\n    function wrapProp(prop, xhr) {\n      if (prop in xhr && typeof (xhr[prop]) === 'function') {\n        polyfill(xhr, prop, function (origin) {\n          return wrap(origin);\n        });\n      }\n    }\n\n    // 复制改下 xhr open 用于监听\n    polyfill(xhrproto, 'open', function (origOpen: any) {\n      return function (method: string, url: string) {\n\n        this._trace_xhr = {\n          method: method,\n          url: url,\n          statusCode: null\n        };\n        return origOpen.apply(this, arguments);\n      };\n    }, wrappedBuiltIns);\n\n    // 复制改下 xhr send 用于监听\n    polyfill(xhrproto, 'send', function (origSend) {\n      return function (data) {\n        var xhr = this;\n        function onreadystatechangeHandler() {\n          if (xhr._trace_xhr && (xhr.readyState === 1 || xhr.readyState === 4)) {\n            xhr._trace_xhr.statusCode = xhr.status;\n            self.captureBreadcrumb({\n              type: 'http',\n              category: 'xhr',\n              data: xhr._trace_xhr\n            });\n          }\n        }\n\n        const props = ['onload', 'onerror', 'onprogress'];\n        for (var j = 0; j < props.length; j++) {\n          wrapProp(props[j], xhr);\n        }\n\n        if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n          polyfill(xhr, 'onreadystatechange', function (origin) {\n            return wrap(origin, undefined, onreadystatechangeHandler);\n          })\n        } else {\n          xhr.onreadystatechange = onreadystatechangeHandler;\n        }\n        return origSend.apply(this, arguments);\n      };\n    }, wrappedBuiltIns);\n  }\n\n  private getLocationBreadcurmbs() {\n    if (!this._config.autoBreadcrumbs.location) return;\n\n    const wrappedBuiltIns = this.wrappedBuiltIns;\n    const self = this;\n    const chrome = window['chrome'];\n    const isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;\n    const hasPushState = !isChromePackagedApp && window.history && history.pushState;\n    if (hasPushState) {\n      var oldOnPopState = window.onpopstate;\n      window.onpopstate = function () {\n        var currentHref = location.href;\n        self.captureUrlChange(self.lastHref, currentHref);\n        if (oldOnPopState) {\n          return oldOnPopState.apply(this, arguments);\n        }\n      };\n\n      polyfill(history, 'pushState', function (origPushState) {\n        // note history.pushState.length is 0; intentionally not declaring\n        // params to preserve 0 arity\n        return function (/* state, title, url */) {\n          var url = arguments.length > 2 ? arguments[2] : undefined;\n\n          // url argument is optional\n          if (url) {\n            // coerce to string (this is what pushState does)\n            self.captureUrlChange(self.lastHref, url + '');\n          }\n\n          return origPushState.apply(this, arguments);\n        };\n      }, wrappedBuiltIns);\n    }\n  }\n\n  /**\n   * Captures a breadcrumb of type \"navigation\", normalizing input URLs\n   * @param to the originating URL\n   * @param from the target URL\n   * @private\n   */\n  private captureUrlChange(from, to) {\n    var parsedLoc = parseUrl(location.href);\n    var parsedTo = parseUrl(to);\n    var parsedFrom = parseUrl(from);\n\n    // because onpopstate only tells you the \"new\" (to) value of location.href, and\n    // not the previous (from) value, we need to track the value of the current URL\n    // state ourselves\n    this.lastHref = to;\n\n    // Use only the path component of the URL if the URL matches the current\n    // document (almost all the time when using pushState)\n    if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host)\n      to = parsedTo.relative;\n    if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host)\n      from = parsedFrom.relative;\n\n    this.captureBreadcrumb({\n      category: 'navigation',\n      data: {\n        to: to,\n        from: from\n      }\n    });\n  }\n\n  private getConsoleBreadcrumbs() {\n    if (!this._config.autoBreadcrumbs.console) return;\n    if ('console' in window && console.log) {\n      const consoleMethodCallback = (msg, data) => {\n        this.captureBreadcrumb({\n          message: msg,\n          level: data.level,\n          category: 'console'\n        });\n      };\n      ['debug', 'info', 'warn', 'error', 'log'].forEach((item) => {\n        this.wrapConsole(console, item, consoleMethodCallback);\n      })\n    }\n  }\n\n  private wrapConsole(console, level, callback) {\n    const originalConsoleLevel = console[level];\n    const originalConsole = console;\n\n    if (!(level in console)) {\n      return;\n    }\n\n    var sentryLevel = level === 'warn'\n      ? 'warning'\n      : level;\n\n    console[level] = function () {\n      var args = [].slice.call(arguments);\n\n      var msg = '' + args.join(' ');\n      var data = { level: sentryLevel, logger: 'console', extra: { 'arguments': args } };\n      callback && callback(msg, data);\n\n      // this fails for some browsers. :(\n      if (originalConsoleLevel) {\n        // IE9 doesn't allow calling apply on console functions directly\n        // See: https://stackoverflow.com/questions/5472938/does-ie9-support-console-log-and-is-it-a-real-function#answer-5473193\n        Function.prototype.apply.call(\n          originalConsoleLevel,\n          originalConsole,\n          args\n        );\n      }\n    };\n  };\n\n  /**\n   * 写入面包屑\n   * @private\n   * @param {Trace.BreadCrumb} crumb \n   */\n  private captureBreadcrumb(crumb: Trace.BreadCrumb): void {\n    let _crumb = objectAssign({}, crumb, { timestamp: new Date().getTime() });\n    this.crumbsData.push(_crumb);\n\n    // 超出后删除最先记录的一个\n    if (this.crumbsData.length > this._config.maxBreadcrumbs) {\n      this.crumbsData.shift()\n    }\n  }\n}","import { makeRequest } from './request';\nimport { environment } from './environment';\nimport { BreadCrumbs } from './breadcrumbs';\nimport { triggerEvent, guid } from './util';\nconst objectAssign = Object.assign || require('object-assign');\nimport Tracekit from './tracekit';\n\nexport class OnError {\n  private _config: Trace.Config;\n  private Tracekit = Tracekit;\n  private breadcrumbs: BreadCrumbs;\n\n  private lastGuid: string = null;\n  private lastReport: Trace.Report = null;\n\n  constructor(config: Trace.Config) {\n    this._config = config;\n    Tracekit['report'].subscribe((errorReport: any) => {\n      this.handleStackInfo(errorReport)\n    })\n    this.breadcrumbs = new BreadCrumbs(config);\n  }\n\n  /**\n   * 处理栈信息\n   * @private\n   * @param {TraceKit.StackTrace} stackInfo TraceKit获取的栈信息\n   */\n  public handleStackInfo(stackInfo: TraceKit.StackTrace): void {\n    let frames: Array<Trace.StackFrame> = this.prepareFrames(stackInfo);\n\n    triggerEvent('handle', { stackInfo });\n\n    this.processException(stackInfo.name, stackInfo.message, stackInfo.url, frames)\n  }\n\n  /**\n   * 设置栈帧数据集\n   * @private\n   * @param {TraceKit.StackTrace} stackInfo TraceKit获取的栈信息\n   * @returns {Trace.StackFrame[]} \n   */\n  public prepareFrames(stackInfo: TraceKit.StackTrace): Trace.StackFrame[] {\n    let frames: Array<Trace.StackFrame> = [];\n    if (stackInfo.stack && stackInfo.stack.length) {\n      stackInfo.stack.forEach(item => {\n        let frame = this.normalizeFrame(item);\n        if (frame) frames.push(frame)\n      });\n    }\n    frames = frames.slice(0, this._config.maxStackDepth);\n    return frames;\n  }\n\n  /**\n   * 统一自定义栈帧结构\n   * @private\n   * @param {TraceKit.StackFrame} frame - TraceKit获取的栈帧\n   * @returns {Trace.StackFrame} - 统一后的栈帧对象\n   */\n  private normalizeFrame(frame: TraceKit.StackFrame): Trace.StackFrame {\n    if (!frame.url) return;\n    const normalized = {\n      fileName: frame.url,\n      lineNumber: frame.line,\n      columnNumber: frame.column,\n      function: frame.func || '?'\n    }\n    return normalized;\n  }\n\n  /**\n   * 处理异常\n   * @private\n   * @param {string} type - 异常类型\n   * @param {string} message - 异常信息\n   * @param {string} fileName - 异常路径\n   * @param {Array<Trace.StackFrame>} frames - 异常栈帧数据集\n   */\n  private processException(type: string, message: string, fileName: string, frames: Array<Trace.StackFrame>): void {\n    let config = this._config;\n    let stacktrace: Array<Trace.StackFrame> = [];\n    if (!!(config.ignoreErrors as RegExp).test && (config.ignoreErrors as RegExp).test(message)) return;\n\n    message += '';\n\n    if (frames && frames.length) {\n      fileName = frames[0].fileName || fileName;\n      frames.reverse(); // 倒序排列\n      stacktrace = frames;\n    } else if (fileName) {\n      stacktrace.push({\n        fileName\n      })\n    }\n\n    if (!!(config.ignoreUrls as RegExp).test && (config.ignoreUrls as RegExp).test(fileName)) return;\n\n    let exception: Array<Trace.CatchedException> = [{ type, message, stacktrace }];\n\n    // 处理报告数据\n    this.handlePayload(exception);\n  }\n\n  /**\n   * 处理报告数据\n   * @private\n   * @param {Array<Trace.CatchedException>} exception \n   */\n  public handlePayload(exception: Array<Trace.CatchedException>) {\n    // 合并报告\n    const reportData: Trace.Report = {\n      url: location.href,\n      title: document.title,\n      environment,\n      exception,\n      version: this._config.version,\n      apiKey: this._config.apiKey,\n      timestamp: new Date().getTime(),\n      guid: guid(),\n      breadcrumbs: this.breadcrumbs.crumbsData,\n    }\n    // 发送报告\n    this.sendPayload(reportData)\n  }\n\n  /**\n   * 发送报告\n   * @private\n   * @param {Trace.Report} payload\n   */\n  private sendPayload(payload: Trace.Report) {\n    if (!this._config.enabled) return;\n\n    this.lastGuid = payload.guid;\n    if (!this._config.repeatReport && this.isRepeatReport(payload)) return;\n\n    this.lastReport = payload;\n    const requestOptions = {\n      url: this._config.reportUrl,\n      data: payload,\n      onSuccess: () => {\n        triggerEvent('success', {\n          data: payload,\n          src: this._config.reportUrl\n        })\n        return new Promise(() => { });\n      },\n      OnError: (error) => {\n        triggerEvent('failure', {\n          data: payload,\n          src: this._config.reportUrl\n        })\n        error = error || new Error(`发送上报请求失败`);\n        return new Promise(resolve => resolve(error))\n      }\n    }\n    // 发送报告请求\n    makeRequest(requestOptions);\n  }\n\n  /**\n   * 判断两份报告是否重复\n   * @private\n   * @param {Trace.Report} current \n   * @returns {boolean} \n   */\n  private isRepeatReport(current: Trace.Report): boolean {\n    const last = this.lastReport;\n\n    // 如果最后一次报告没有或者两个 report 的 URL 都不相同直接返回 false\n    if (!last || current.url !== last.url) return false;\n\n    if (current.exception || last.exception) {\n      return this.isSameException(current.exception, last.exception);\n    }\n    return true;\n  }\n\n  /**\n   * 判断两个异常数据集是否重复\n   * @private\n   * @param {Trace.CatchedException[]} arrayEx1 \n   * @param {Trace.CatchedException[]} arrayEx2 \n   * @returns {boolean} \n   */\n  private isSameException(arrayEx1: Trace.CatchedException[], arrayEx2: Trace.CatchedException[]): boolean {\n    if (!arrayEx1.length || !arrayEx2.length) return false;\n\n    const ex1: Trace.CatchedException = arrayEx1[0];\n    const ex2: Trace.CatchedException = arrayEx2[0];\n\n    if (ex1.type !== ex2.type || ex1.message !== ex2.message) return false;\n\n    return this.isSameStacktrace(ex1.stacktrace, ex2.stacktrace);\n  }\n\n  /**\n   * 判断两个栈帧数据集是否重复\n   * @private\n   * @param {Trace.StackFrame[]} stacktrace1 \n   * @param {Trace.StackFrame[]} stacktrace2 \n   * @returns {boolean} \n   */\n  private isSameStacktrace(stacktrace1: Trace.StackFrame[], stacktrace2: Trace.StackFrame[]): boolean {\n    if (!stacktrace1.length || !stacktrace2.length) return false;\n\n    stacktrace1.forEach((item, index) => {\n      if (item.fileName !== stacktrace2[index].fileName ||\n        item.columnNumber !== stacktrace2[index].columnNumber ||\n        item.lineNumber !== stacktrace2[index].lineNumber ||\n        item.function !== stacktrace2[index].function) return false;\n    })\n\n    return true;\n  }\n}\n","import { defaultConfig } from './config';\nimport { OnError } from './onError';\nimport { joinRegExp, isError } from './util';\nimport Tracekit from './tracekit';\nconst objectAssign = Object.assign || require('object-assign');\n\nexport default class Trace {\n  private computeStackTrace: TraceKit.ComputeStackTrace = Tracekit['computeStackTrace'];\n  private globalConfig: Trace.Config = defaultConfig;\n  private onError: OnError;\n\n  constructor(config?: Trace.Config) {\n    this.globalConfig = objectAssign({}, this.globalConfig, config);\n    this.handleConfig();\n    this.onError = new OnError(this.globalConfig);\n  }\n\n  public captureException(exception: any): void {\n    if (!isError(exception)) {\n      return this.captureMessage(exception);\n    }\n\n    try {\n      const stack: TraceKit.StackTrace = this.computeStackTrace(exception);\n      this.onError.handleStackInfo(stack);\n    } catch (e) {\n      if (exception !== e) throw e;\n    }\n  }\n\n  public captureMessage(message: string): void {\n    if (!!(this.globalConfig.ignoreErrors as RegExp).test\n      && (this.globalConfig.ignoreErrors as RegExp).test(message)) return;\n\n    let exception: any;\n    try {\n      throw new Error(message);\n    } catch (e) {\n      exception = e;\n    }\n\n    let stack = this.computeStackTrace(exception);\n    let frames: Trace.StackFrame[] = this.onError.prepareFrames(stack);\n\n    let catchedException: Trace.CatchedException = {\n      stacktrace: frames,\n      message\n    }\n\n    this.onError.handlePayload([catchedException]);\n  }\n\n  private handleConfig() {\n    const ignoreErrors = this.globalConfig.ignoreErrors as Array<RegExp>;\n    const ignoreUrls = this.globalConfig.ignoreErrors as Array<RegExp>;\n\n    ignoreErrors.push(/^Script error\\.?$/);\n    ignoreErrors.push(/^Javascript error: Script error\\.? on line 0$/);\n    this.globalConfig.ignoreErrors = joinRegExp(ignoreErrors);\n\n    this.globalConfig.ignoreUrls = ignoreUrls.length && joinRegExp(ignoreUrls);\n  }\n}\n"],"names":["options","request","XMLHttpRequest","XDomainRequest","url","onreadystatechange","readyState","status","onSuccess","onError","error","Error","replace","onload","onerror","open","send","JSON","stringify","data","value","Object","prototype","toString","call","crypto","window","getRandomValues","arr","Uint16Array","pad","num","v","length","c","r","Math","random","eventType","document","_event","key","substr","toUpperCase","createEvent","initEvent","hasOwnProperty","dispatchEvent","toLowerCase","obj","name","replacement","track","origin","push","func","args","i","arguments","deep","apply","this","wrap","e","undefined","trace","track_wrapper","property","process","wrapped","patterns","sources","pattern","source","RegExp","join","element","nextStr","out","height","len","sepLength","htmlElementAsString","parentElement","reverse","className","classes","attr","tagName","id","split","attrWhitelist","getAttribute","match","query","fragment","result","attributes","item","getLocationHref","location","href","defaultConfig","environment","documentElement","clientWidth","body","clientHeight","navigator","userAgent","language","objectAssign","assign","require","config","_config","getDomBreadcrumbs","getXhrBreadcrumbs","getLocationBreadcurmbs","getConsoleBreadcrumbs","autoBreadcrumbs","dom","clickEventSelectors","changeEventSelectors","addEventListener","event","eventHandler","_this","eventName","selectorFilters","target","srcElement","acceptTag","getAttributes","htmlTreeAsString","captureBreadcrumb","selectors","tag","indexOf","prop","xhr","self","wrappedBuiltIns","xhrproto","origOpen","method","_trace_xhr","origSend","statusCode","props","j","onreadystatechangeHandler","chrome","app","runtime","history","pushState","oldOnPopState","onpopstate","currentHref","captureUrlChange","lastHref","origPushState","from","to","parsedLoc","parseUrl","parsedTo","parsedFrom","protocol","host","relative","console","log","consoleMethodCallback","msg","level","forEach","wrapConsole","callback","originalConsoleLevel","originalConsole","sentryLevel","slice","logger","extra","crumb","_crumb","timestamp","Date","getTime","crumbsData","maxBreadcrumbs","shift","TraceKit","_window","global","_slice","UNKNOWN_FUNCTION","ERROR_TYPES_RE","report","subscribe","handler","unsubscribe","handlers","splice","unsubscribeAll","notifyHandlers","stack","isWindowError","exception","collectWindowErrors","concat","inner","traceKitWindowOnError","message","lineNo","colNo","ex","lastExceptionStack","computeStackTrace","augmentStackTraceWithInitialElement","groups","_oldOnerrorHandler","installGlobalHandler","_onErrorHandlerInstalled","uninstallGlobalHandler","processLastException","_lastExceptionStack","_lastArgs","lastArgs","rethrow","lastException","incomplete","uninstall","computeStackTraceFromStackProp","submatch","parts","gecko","winjs","chromeEval","lines","exec","isNative","isEval","geckoEval","columnNumber","column","line","stackInfo","initial","unshift","partial","computeStackTraceByWalkingCallerChain","depth","functionName","funcs","recursion","curr","caller","input","substring","sourceURL","fileName","lineNumber","description","debug","Tracekit","errorReport","handleStackInfo","breadcrumbs","BreadCrumbs","frames","prepareFrames","processException","frame","_this2","normalizeFrame","maxStackDepth","type","stacktrace","ignoreErrors","test","ignoreUrls","handlePayload","reportData","title","version","apiKey","guid","sendPayload","payload","enabled","lastGuid","repeatReport","isRepeatReport","lastReport","reportUrl","_this3","Promise","resolve","current","last","isSameException","arrayEx1","arrayEx2","ex1","ex2","isSameStacktrace","stacktrace1","stacktrace2","index","function","globalConfig","handleConfig","OnError","isError","captureMessage","catchedException","joinRegExp"],"mappings":"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"}